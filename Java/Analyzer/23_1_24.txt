1. Разработать класс, реализующий итератор, который в конструкторе принимает диапазон чисел и позволяет перебирать в цикле for простые числа в указанном диапазоне
2. Разработать класс, реализующий итератор, который в конструкторе принимает путь к папке и перебирает все подпапки и файлы в указанной папке и в подпапках
3. Пользователь вводит имя папки, программа по таймеру делает резервную копию папки в папку BackUp (изменения) и ведёт лог процесса (реализовать паттерн "Наблюдатель")

4. Найти все простые числа в диапазоне [2, 1000000] и найденные числа сохранить в файл отчёта. Задачу решить в одном потоке, в двух и четырёх потоках и засечь время.
5. Программа копирует файлы из одной папки в другую (много файлов и большой размер папки). Изучить эффективность многопоточности на решение этой задачи (1, 2, 4, 8 потоков)
Всегда засекать время

6. Ускорить любой метод сортировки при помощи распоточивания. Можно использовать любые методы синхронизации, если это потребуется. Изучить влияние количества потоков на
скорость сортировки. Засечь время. Отсортированную последовательность сохранить.

6a. Изменить предыдущую программу с отправителем и получателем так, чтобы получателей было 2 и они получали пакеты в строго определённом порядке:
Put: 0
Get 1: 0
Get 2: 0
Put: 1
Get 1: 1
Get 2: 1

7. Разработать шаблонный класс-коллекцию DoubleLinkedList, двусвязный список, имеющий следующие методы:
- Add(T n)
- AddFirst(T n)
- Insert(T n, int pos)
- Print()
- PrintBack()
- Delete(T n)
- DeleteByPos(int pos)

8. Разработать класс Graph<T>, по аналогии с тем, который был выполнен на C# ранее

9. Класс Analizer имеет метод AnalizeMethods(Object obj), принимающий ссылку на анализируемый объект.
Метод AnalizeMethods возвращает словарь, в котором ключом является название типа метода, а значением является количество аргументов метода.

9a. Добавить в класс Analizer метод RunMethods, принимающий ссылку на анализируемый объект.
Этот метод запускает все обнаруженные методы в анализируемом классе и передаёт им нужные параметры. Типы поддерживаемых параметров (int, double, String).
Запуск производить через invoke

9b. Разработать свой механизм сериализации, основанный на Reflection. Сериализующий класс называется MySerializer. Ниже показанный код должен работать.
Сериализовать надо все обнаруженные поля. (Объявленные или унаследованные). Формат сериализации - любой

		// Сериализация
		/*MySerializer serializer = new MySerializer();
    	Person p = new Person();
    	FileOutputStream os = new FileOutputStream("testing.dat");
    	serializer.Serialize(p, os);
    	
		// Десериализация
    	FileInputStream is = new FileInputStream("testing.dat");
    	Person p2 = (Person)serializer.Deserialize(Person.class, os);
    	p2.print();*/
    	
		// Создание экземпляра класса
    	/*Class<Person> personClass = Person.class;
    	Person person = personClass.getDeclaredConstructor().newInstance();
    	person.print();*/
		
10. В задачу с сериализатором 9b добавить аннотации:
@Serializable (для классов, показывает, что экземпляр этого класса может быть сериализован),
@Serialize (для полей сериализуемых классаов, показывает, что указанное поле класса должно быть сериализовано в процессе сериализации)